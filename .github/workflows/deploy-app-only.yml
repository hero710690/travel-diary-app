name: Deploy Travel Diary App (Manual CDN + DynamoDB)

on:
  push:
    branches: [ main ]
    paths:
      - 'python-backend/**'
      - 'client/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

env:
  AWS_REGION: ap-northeast-1
  PROJECT_NAME: travel-diary
  ENVIRONMENT: prod
  # Manual infrastructure names
  S3_BUCKET_NAME: travel-diary-prod-frontend
  CLOUDFRONT_COMMENT: "Travel Diary App CDN - prod"

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Python dependencies
      run: |
        cd python-backend
        pip install -r requirements-lambda.txt
        pip install pytest pytest-asyncio
    
    - name: Run Python tests
      run: |
        cd python-backend
        python -m pytest tests/ -v || echo "No tests found, skipping..."
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install Frontend dependencies
      working-directory: client
      run: |
        if [ ! -f package-lock.json ]; then
          echo "ðŸ“¦ No package-lock.json found, running npm install..."
          npm install
        else
          echo "ðŸ“¦ Found package-lock.json, checking sync..."
          npm ci || {
            echo "âš ï¸ package-lock.json out of sync, regenerating..."
            rm package-lock.json
            npm install
          }
        fi
    
    - name: Run Frontend tests
      working-directory: client
      run: |
        npm test -- --coverage --watchAll=false || echo "No frontend tests found, skipping..."

  deploy:
    name: Deploy Application (Lambda + Frontend)
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Verify Manual Infrastructure
      run: |
        echo "ðŸ” Verifying manually deployed infrastructure..."
        
        # Check DynamoDB tables exist
        echo "Checking DynamoDB tables..."
        aws dynamodb describe-table --table-name travel-diary-prod-users-serverless --region ${{ env.AWS_REGION }} && echo "âœ… Users table exists" || echo "âŒ Users table missing"
        aws dynamodb describe-table --table-name travel-diary-prod-trips-serverless --region ${{ env.AWS_REGION }} && echo "âœ… Trips table exists" || echo "âŒ Trips table missing"
        aws dynamodb describe-table --table-name travel-diary-prod-sessions-serverless --region ${{ env.AWS_REGION }} && echo "âœ… Sessions table exists" || echo "âŒ Sessions table missing"
        
        # Check S3 bucket exists
        echo "Checking S3 bucket..."
        aws s3 ls s3://${{ env.S3_BUCKET_NAME }} --region ${{ env.AWS_REGION }} && echo "âœ… S3 bucket exists" || echo "âŒ S3 bucket missing"
        
        # Check CloudFront distribution
        echo "Checking CloudFront distribution..."
        DISTRIBUTION_ID=$(aws cloudfront list-distributions --query 'DistributionList.Items[?Comment==`${{ env.CLOUDFRONT_COMMENT }}`].Id' --output text)
        if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
          echo "âœ… CloudFront distribution exists: $DISTRIBUTION_ID"
        else
          echo "âŒ CloudFront distribution not found"
        fi
    
    - name: Build Lambda package
      run: |
        echo "ðŸ Building Lambda deployment package..."
        mkdir -p lambda-package
        cd python-backend
        
        # Install dependencies with platform targeting
        pip install -r requirements-lambda.txt \
          -t ../lambda-package \
          --no-deps \
          --platform linux_x86_64 \
          --only-binary=:all: || \
        pip install -r requirements-lambda.txt \
          -t ../lambda-package \
          --no-deps
        
        # Copy application code
        cp -r . ../lambda-package/
        
        # Clean up and create package
        cd ../lambda-package
        find . -name "*.pyc" -delete
        find . -name "__pycache__" -type d -exec rm -rf {} + || true
        zip -r ../backend.zip . -x "tests/*" "*.git*" "requirements*.txt"
        cd ..
        rm -rf lambda-package
        
        echo "ðŸ“¦ Lambda package created:"
        ls -lh backend.zip
    
    - name: Deploy Lambda Function
      run: |
        echo "ðŸš€ Deploying Lambda function..."
        
        # Create environment variables JSON file
        echo '{
          "Variables": {
            "DATABASE_TYPE": "dynamodb",
            "USERS_TABLE": "travel-diary-prod-users-serverless",
            "TRIPS_TABLE": "travel-diary-prod-trips-serverless",
            "SESSIONS_TABLE": "travel-diary-prod-sessions-serverless",
            "ENVIRONMENT": "prod",
            "DEBUG": "false",
            "SECRET_KEY": "${{ secrets.JWT_SECRET_KEY }}",
            "GOOGLE_MAPS_API_KEY": "${{ secrets.GOOGLE_MAPS_API_KEY }}"
          }
        }' > /tmp/lambda-env.json
        
        # Function to wait for Lambda to be ready
        wait_for_lambda_ready() {
          local function_name=$1
          local max_attempts=30
          local attempt=1
          
          echo "â³ Waiting for Lambda function to be ready..."
          
          while [ $attempt -le $max_attempts ]; do
            STATE=$(aws lambda get-function --function-name $function_name --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "NotFound")
            LAST_UPDATE_STATUS=$(aws lambda get-function --function-name $function_name --region ${{ env.AWS_REGION }} --query 'Configuration.LastUpdateStatus' --output text 2>/dev/null || echo "NotFound")
            
            echo "Attempt $attempt/$max_attempts - State: $STATE, LastUpdateStatus: $LAST_UPDATE_STATUS"
            
            if [ "$STATE" = "Active" ] && [ "$LAST_UPDATE_STATUS" = "Successful" ]; then
              echo "âœ… Lambda function is ready"
              return 0
            elif [ "$STATE" = "Failed" ] || [ "$LAST_UPDATE_STATUS" = "Failed" ]; then
              echo "âŒ Lambda function is in failed state"
              return 1
            fi
            
            echo "â³ Lambda function not ready, waiting 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "âŒ Timeout waiting for Lambda function to be ready"
          return 1
        }
        
        # Check if Lambda function exists
        if aws lambda get-function --function-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ðŸ“ Updating existing Lambda function..."
          
          # Wait for any in-progress updates to complete
          wait_for_lambda_ready ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend
          
          # Update function code
          echo "ðŸ“¦ Updating Lambda function code..."
          aws lambda update-function-code \
            --function-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
            --zip-file fileb://backend.zip \
            --region ${{ env.AWS_REGION }}
          
          # Wait for code update to complete
          wait_for_lambda_ready ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend
          
          # Update environment variables
          echo "ðŸ”§ Updating Lambda environment variables..."
          aws lambda update-function-configuration \
            --function-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
            --environment file:///tmp/lambda-env.json \
            --region ${{ env.AWS_REGION }}
          
          # Wait for configuration update to complete
          wait_for_lambda_ready ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend
          
        else
          echo "ðŸ†• Creating new Lambda function..."
          
          # First, create IAM role for Lambda
          ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-lambda-role --query 'Role.Arn' --output text 2>/dev/null || echo "")
          
          if [ -z "$ROLE_ARN" ]; then
            echo "ðŸ”‘ Creating Lambda execution role..."
            
            # Create trust policy
            echo '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "lambda.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }' > /tmp/trust-policy.json
            
            # Create IAM role
            aws iam create-role \
              --role-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-lambda-role \
              --assume-role-policy-document file:///tmp/trust-policy.json
            
            # Attach basic execution policy
            aws iam attach-role-policy \
              --role-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-lambda-role \
              --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
            
            # Create DynamoDB access policy
            echo '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:GetItem",
                    "dynamodb:PutItem",
                    "dynamodb:Query",
                    "dynamodb:Scan",
                    "dynamodb:UpdateItem",
                    "dynamodb:DeleteItem",
                    "dynamodb:BatchGetItem",
                    "dynamodb:BatchWriteItem"
                  ],
                  "Resource": [
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-users-serverless",
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-trips-serverless",
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-sessions-serverless",
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-users-serverless/index/*",
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-trips-serverless/index/*",
                    "arn:aws:dynamodb:*:*:table/travel-diary-prod-sessions-serverless/index/*"
                  ]
                }
              ]
            }' > /tmp/dynamodb-policy.json
            
            # Attach DynamoDB policy
            aws iam put-role-policy \
              --role-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-lambda-role \
              --policy-name DynamoDBAccess \
              --policy-document file:///tmp/dynamodb-policy.json
            
            # Get role ARN
            ROLE_ARN=$(aws iam get-role --role-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-lambda-role --query 'Role.Arn' --output text)
            
            # Wait for role to be ready
            echo "â³ Waiting for IAM role to be ready..."
            sleep 15
          fi
          
          # Create Lambda function
          echo "ðŸš€ Creating Lambda function..."
          aws lambda create-function \
            --function-name ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
            --runtime python3.11 \
            --role $ROLE_ARN \
            --handler app.lambda_handler.lambda_handler \
            --zip-file fileb://backend.zip \
            --timeout 30 \
            --memory-size 512 \
            --environment file:///tmp/lambda-env.json \
            --region ${{ env.AWS_REGION }}
          
          # Wait for function to be ready
          wait_for_lambda_ready ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend
        fi
        
        # Clean up temp files
        rm -f /tmp/lambda-env.json /tmp/trust-policy.json /tmp/dynamodb-policy.json
        
        echo "âœ… Lambda function deployed successfully"
    
    - name: Build and Deploy Frontend
      run: |
        echo "âš›ï¸ Building React frontend..."
        cd client
        
        # Clean everything for a fresh start
        echo "ðŸ§¹ Cleaning npm cache and dependencies..."
        npm cache clean --force
        rm -rf node_modules package-lock.json
        
        # Verify Node.js and npm versions
        echo "ðŸ“‹ Environment info:"
        node --version
        npm --version
        
        # Install dependencies with all required packages
        echo "ðŸ“¦ Installing dependencies (including TypeScript)..."
        npm install --legacy-peer-deps
        
        # Verify critical dependencies are installed
        echo "ðŸ” Verifying critical dependencies..."
        if [ ! -d "node_modules/typescript" ]; then
          echo "âŒ TypeScript missing, installing explicitly..."
          npm install typescript@^4.9.5 --save --legacy-peer-deps
        fi
        
        if [ ! -d "node_modules/react-scripts" ]; then
          echo "âŒ React Scripts missing, installing explicitly..."
          npm install react-scripts@5.0.1 --save --legacy-peer-deps
        fi
        
        # List key dependencies to verify
        echo "ðŸ“‹ Key dependencies check:"
        ls -la node_modules/ | grep -E "(typescript|react-scripts)" || echo "Some dependencies not found"
        
        # Build production bundle
        echo "ðŸ—ï¸ Building production bundle..."
        GENERATE_SOURCEMAP=false CI=false npm run build
        
        echo "ðŸ“¦ Frontend build completed:"
        if [ -d "build" ]; then
          ls -la build/
          echo "âœ… Build directory created successfully"
        else
          echo "âŒ Build directory not found"
          exit 1
        fi
        
        # Deploy to manually created S3 bucket
        echo "ðŸª£ Deploying to S3 bucket: ${{ env.S3_BUCKET_NAME }}"
        aws s3 sync build/ s3://${{ env.S3_BUCKET_NAME }} \
          --delete \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… Frontend deployed to S3"
    
    - name: Invalidate CloudFront Cache
      run: |
        echo "ðŸŒ Invalidating CloudFront cache..."
        
        # Get CloudFront distribution ID by comment
        DISTRIBUTION_ID=$(aws cloudfront list-distributions \
          --query 'DistributionList.Items[?Comment==`${{ env.CLOUDFRONT_COMMENT }}`].Id' \
          --output text)
        
        if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
          echo "Distribution ID: $DISTRIBUTION_ID"
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*" \
            --region ${{ env.AWS_REGION }}
          echo "âœ… CloudFront cache invalidated"
        else
          echo "âš ï¸ CloudFront distribution not found - skipping cache invalidation"
        fi
    
    - name: Get Deployment URLs
      run: |
        # Get CloudFront URL
        CLOUDFRONT_URL=$(aws cloudfront list-distributions \
          --query 'DistributionList.Items[?Comment==`${{ env.CLOUDFRONT_COMMENT }}`].DomainName' \
          --output text)
        
        # Get API Gateway URL (if exists)
        API_URL="https://$(aws apigateway get-rest-apis --query 'items[?name==`${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-api`].id' --output text).execute-api.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ENVIRONMENT }}"
        
        if [ -n "$CLOUDFRONT_URL" ] && [ "$CLOUDFRONT_URL" != "None" ]; then
          APPLICATION_URL="https://$CLOUDFRONT_URL"
        else
          APPLICATION_URL="https://${{ env.S3_BUCKET_NAME }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
        fi
        
        echo "ðŸš€ Deployment completed successfully!"
        echo ""
        echo "ðŸ“Š Deployment Summary:"
        echo "ðŸŒ Application URL: $APPLICATION_URL"
        echo "ðŸ”— API Gateway URL: $API_URL"
        echo ""
        echo "ðŸ“‹ Infrastructure:"
        echo "  âœ… Lambda function deployed (automated)"
        echo "  âœ… Frontend deployed (automated)"
        echo "  ðŸ”§ DynamoDB tables (manual)"
        echo "  ðŸ”§ S3 bucket (manual)"
        echo "  ðŸ”§ CloudFront CDN (manual)"
        echo "  ðŸ”§ API Gateway (manual)"
        
        # Set outputs for GitHub
        echo "APPLICATION_URL=$APPLICATION_URL" >> $GITHUB_ENV
        echo "API_URL=$API_URL" >> $GITHUB_ENV
    
    - name: Create Deployment Summary
      run: |
        echo "## ðŸš€ Travel Diary Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŽ¯ Deployment Status: âœ… SUCCESS" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŒ Application URLs" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend**: [$APPLICATION_URL]($APPLICATION_URL)" >> $GITHUB_STEP_SUMMARY
        echo "- **API**: [$API_URL]($API_URL)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Infrastructure Components" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Lambda Function**: Backend API deployed (automated)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Frontend**: React app deployed (automated)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”§ **DynamoDB**: Database tables (manual deployment)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”§ **S3 Bucket**: Frontend hosting (manual deployment)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”§ **CloudFront**: CDN distribution (manual deployment)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”§ **API Gateway**: REST API (manual deployment)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Manual Infrastructure Required" >> $GITHUB_STEP_SUMMARY
        echo "The following components must be deployed manually:" >> $GITHUB_STEP_SUMMARY
        echo "- **DynamoDB Tables**: travel-diary-prod-*-serverless" >> $GITHUB_STEP_SUMMARY
        echo "- **S3 Bucket**: ${{ env.S3_BUCKET_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **CloudFront**: Distribution with comment '${{ env.CLOUDFRONT_COMMENT }}'" >> $GITHUB_STEP_SUMMARY
        echo "- **API Gateway**: REST API for Lambda integration" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ’° Architecture Benefits" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”„ **Hybrid Deployment**: Critical infrastructure manual, apps automated" >> $GITHUB_STEP_SUMMARY
        echo "- âš¡ **Fast Deployments**: Only app components updated (~2-3 minutes)" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸŒ **Stable CDN**: No CloudFront recreation on each deploy" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”’ **Production Ready**: Manual control over persistent infrastructure" >> $GITHUB_STEP_SUMMARY
